// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TopViewer.ShadowMaterial = (function(superClass) {
    extend(ShadowMaterial, superClass);

    function ShadowMaterial(model) {
      this.model = model;
      ShadowMaterial.__super__.constructor.call(this, this.model, {
        vertexShader: "precision highp float;\nprecision highp int;\n\nuniform mat4 viewMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform float frameProgress;\n\nuniform sampler2D basePositionsTexture;\nuniform sampler2D displacementsTexture;\nuniform sampler2D displacementsTextureNext;\nuniform float displacementFactor;\n\nuniform float time;\n\nattribute vec2 vertexIndexCorner1;\nattribute vec2 vertexIndexCorner2;\nattribute vec2 vertexIndexCorner3;\nattribute float cornerIndex;\n\nvoid main()	{\n  vec2 vertexIndices[3];\n  vertexIndices[0] = vertexIndexCorner1;\n  vertexIndices[1] = vertexIndexCorner2;\n  vertexIndices[2] = vertexIndexCorner3;\n\n  // Start by calculating all 3 triangle corners and the normal of the triangle.\n  vec3 vertexPositions[3];\n\n  for (int i=0; i<3; i++) {\n    vec4 positionData = texture2D(basePositionsTexture, vertexIndices[i]);\n    vertexPositions[i] = positionData.xyz;\n\n    if (displacementFactor > 0.0) {\n      positionData = texture2D(displacementsTexture, vertexIndices[i]);\n      vec4 positionDataNext = texture2D(displacementsTextureNext, vertexIndices[i]);\n      positionData = mix(positionData, positionDataNext, frameProgress);\n\n      vertexPositions[i] += positionData.xyz * displacementFactor;\n    }\n  }\n\n  // Determine which corner we're currently at and pass its position to the fragment shader.\n  vec2 vertexIndex;\n  vec3 vertexPosition;\n\n  if (cornerIndex < 0.05) {vertexIndex = vertexIndices[0]; vertexPosition = vertexPositions[0];}\n  else if (cornerIndex < 0.15) {vertexIndex = vertexIndices[1]; vertexPosition = vertexPositions[1];}\n  else {vertexIndex = vertexIndices[2]; vertexPosition = vertexPositions[2];}\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);\n}",
        fragmentShader: "precision highp float;\nprecision highp int;\n\nuniform float time;\n\n" + THREE.ShaderChunk.packing + "\n\nvoid main()	{\n  gl_FragColor = packDepthToRGBA(gl_FragCoord.z);\n}"
      });
    }

    return ShadowMaterial;

  })(TopViewer.PositionsMaterial);

}).call(this);

//# sourceMappingURL=shadowmaterial.js.map
