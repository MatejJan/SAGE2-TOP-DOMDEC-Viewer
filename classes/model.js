// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TopViewer.Model = (function(superClass) {
    extend(Model, superClass);

    function Model(options) {
      this.options = options;
      Model.__super__.constructor.apply(this, arguments);
      this.matrixAutoUpdate = false;
      this.nodes = this.options.nodes;
      this.positions = null;
      this.colors = null;
      this.positionAttribute = null;
      this.colorAttribute = null;
      this.meshes = {};
      this.scalars = {};
      this.vectors = {};
      this.frames = [
        {
          frameTime: -1
        }
      ];
      this.positions = this.nodes.slice();
      this.positionAttribute = new THREE.BufferAttribute(this.positions, 3);
      this.colors = new Float32Array(this.positions.length);
      this.colorAttribute = new THREE.BufferAttribute(this.colors, 3);
      if (this.positions.length) {
        this.options.engine.scene.addModel(this);
      }
      this._updateFrames();
    }

    Model.prototype.addElements = function(elementsName, elementsInstance) {
      return this.meshes[elementsName] = new TopViewer.Mesh({
        name: elementsName,
        positionAttribute: this.positionAttribute,
        colorAttribute: this.colorAttribute,
        elements: elementsInstance.elements,
        model: this,
        engine: this.options.engine
      });
    };

    Model.prototype.addScalar = function(scalarName, scalar) {
      this.scalars[scalarName] = scalar;
      return this._updateFrames();
    };

    Model.prototype.addVector = function(vectorName, vector) {
      this.vectors[vectorName] = vector;
      this._updateFrames();
      return this.options.engine.renderingControls.addVector(vectorName, vector);
    };

    Model.prototype._updateFrames = function() {
      var frame, frameTime, frameTimes, i, j, k, l, len, len1, len2, len3, m, n, newFrame, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, results, scalar, scalarFrame, scalarName, vector, vectorFrame, vectorName;
      frameTimes = [];
      ref = this.scalars;
      for (scalarName in ref) {
        scalar = ref[scalarName];
        ref1 = scalar.frames;
        for (j = 0, len = ref1.length; j < len; j++) {
          frame = ref1[j];
          frameTimes = _.union(frameTimes, [parseFloat(frame.time)]);
        }
      }
      ref2 = this.vectors;
      for (vectorName in ref2) {
        vector = ref2[vectorName];
        ref3 = vector.frames;
        for (k = 0, len1 = ref3.length; k < len1; k++) {
          frame = ref3[k];
          frameTimes = _.union(frameTimes, [parseFloat(frame.time)]);
        }
      }
      frameTimes.sort(function(a, b) {
        return a - b;
      });
      this.options.engine.animation.addFrameTimes(frameTimes);
      if (!frameTimes.length) {
        frameTimes.push(-1);
      }
      this.frames = [];
      results = [];
      for (l = 0, len2 = frameTimes.length; l < len2; l++) {
        frameTime = frameTimes[l];
        newFrame = {
          time: frameTime,
          vectors: []
        };
        ref4 = this.scalars;
        for (scalarName in ref4) {
          scalar = ref4[scalarName];
          for (i = m = 0, ref5 = scalar.frames.length; 0 <= ref5 ? m < ref5 : m > ref5; i = 0 <= ref5 ? ++m : --m) {
            scalarFrame = scalar.frames[i];
            if (frameTime !== scalarFrame.time) {
              continue;
            }
            newFrame.scalarName = scalarName;
            newFrame.scalarFrame = scalarFrame;
          }
        }
        ref6 = this.vectors;
        for (vectorName in ref6) {
          vector = ref6[vectorName];
          ref7 = vector.frames;
          for (n = 0, len3 = ref7.length; n < len3; n++) {
            vectorFrame = ref7[n];
            if (frameTime !== vectorFrame.time) {
              continue;
            }
            newFrame.vectors.push({
              vectorName: vectorName,
              vectorFrame: vectorFrame
            });
          }
        }
        results.push(this.frames.push(newFrame));
      }
      return results;
    };

    Model.prototype.showFrame = function(frameTime) {
      var displacementFactor, frame, frameIndex, gradientData, gradientIndex, i, j, k, l, len, m, mesh, meshName, mustRepaint, n, normalizeFactor, normalizedValue, o, offset, p, range, ref, ref1, ref2, ref3, ref4, ref5, ref6, renderingControls, results, scalar, testFrame, time, value, vector;
      frame = null;
      for (frameIndex = j = 0, ref = this.frames.length; 0 <= ref ? j < ref : j > ref; frameIndex = 0 <= ref ? ++j : --j) {
        testFrame = this.frames[frameIndex];
        time = testFrame.time;
        if (time === frameTime || time === -1) {
          frame = testFrame;
        }
      }
      this.visible = frame && this.nodes.length;
      if (!this.visible) {
        return;
      }
      renderingControls = this.options.engine.renderingControls;
      if (frame.scalarFrame && this.options.engine.gradientData) {
        mustRepaint = this._paintedWhite || this._currentScalarFrame !== frame.scalarFrame;
        if (this._gradientMapLastUpdate !== renderingControls.gradientCurve.lastUpdated) {
          this._gradientMapLastUpdate = renderingControls.gradientCurve.lastUpdated;
          mustRepaint = true;
        }
        scalar = this.scalars[frame.scalarName];
        if (scalar._limitsVersion !== scalar.limits.version) {
          mustRepaint = true;
        }
        if (mustRepaint) {
          range = scalar.limits.maxValue - scalar.limits.minValue;
          normalizeFactor = range ? 1 / range : 1;
          gradientData = this.options.engine.gradientData;
          for (i = k = 0, ref1 = frame.scalarFrame.scalars.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
            value = frame.scalarFrame.scalars[i];
            normalizedValue = (value - scalar.limits.minValue) * normalizeFactor;
            normalizedValue = renderingControls.gradientCurve.getY(normalizedValue);
            gradientIndex = Math.floor((gradientData.length / 4 - 1) * normalizedValue) * 4;
            for (offset = l = 0; l <= 2; offset = ++l) {
              this.colors[i * 3 + offset] = gradientData[gradientIndex + offset];
            }
          }
          this._paintedWhite = false;
          this._currentScalarFrame = frame.scalarFrame;
          scalar._limitsVersion = scalar.limits.version;
          this.colorAttribute.needsUpdate = true;
        }
      } else {
        if (!this._paintedWhite) {
          for (i = m = 0, ref2 = this.colors.length; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {
            this.colors[i] = 1;
          }
          this._paintedWhite = true;
          this.colorAttribute.needsUpdate = true;
        }
      }
      for (i = n = 0, ref3 = this.positions.length; 0 <= ref3 ? n < ref3 : n > ref3; i = 0 <= ref3 ? ++n : --n) {
        this.positions[i] = this.nodes[i];
      }
      this.positionAttribute.needsUpdate = true;
      ref4 = frame.vectors;
      for (o = 0, len = ref4.length; o < len; o++) {
        vector = ref4[o];
        if (vector.vectorFrame) {
          displacementFactor = this.vectors[vector.vectorName].renderingControls.displacementFactor.value;
          if (!(this._currentDisplacementFactor === displacementFactor && this._currentVectorFrame === frame.vectorFrame)) {
            this._currentVectorFrame = vector.vectorFrame;
            this._currentDisplacementFactor = displacementFactor;
            for (i = p = 0, ref5 = this.nodes.length; 0 <= ref5 ? p < ref5 : p > ref5; i = 0 <= ref5 ? ++p : --p) {
              this.positions[i] += vector.vectorFrame.vectors[i] * displacementFactor;
            }
            this.positionAttribute.needsUpdate = true;
          }
        }
      }
      ref6 = this.meshes;
      results = [];
      for (meshName in ref6) {
        mesh = ref6[meshName];
        results.push(mesh.showFrame());
      }
      return results;
    };

    return Model;

  })(THREE.Object3D);

}).call(this);

//# sourceMappingURL=model.js.map
