// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TopViewer.Scene = (function(superClass) {
    extend(Scene, superClass);

    function Scene(options) {
      Scene.__super__.constructor.call(this);
      this.engine = options.engine;
      this.ambientLight = new THREE.AmbientLight(0xffffff, 0);
      this.add(this.ambientLight);
      this.directionalLight = this.addShadowedLight(0, 1, 0, 0xffffff, 1);
      this.planeMaterial = new THREE.MeshLambertMaterial({
        color: 0x444550
      });
      this.plane = new THREE.PlaneGeometry(20, 20);
      this.floor = new THREE.Mesh(this.plane, this.planeMaterial);
      this.floor.rotation.x = -Math.PI * 0.5;
      this.floor.rotation.z = -Math.PI * 0.5;
      this.floor.receiveShadow = true;
      this.floor.castShadow = false;
      this.add(this.floor);
      this.normalizationMatrix = new THREE.Matrix4();
      this.rotationMatrix = new THREE.Matrix4();
      this.scaleMatrix = new THREE.Matrix4();
      this.translationMatrix = new THREE.Matrix4();
      this._currentFrameSet = [];
      this.sceneBoundingBox = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
    }

    Scene.prototype.destroy = function() {
      this.remove.apply(this, this.children);
      return this.planeMaterial.dispose();
    };

    Scene.prototype.addShadowedLight = function(x, y, z, color, intensity) {
      var directionalLight;
      directionalLight = new THREE.DirectionalLight(color, intensity);
      directionalLight.position.set(x, y, z);
      directionalLight.castShadow = true;
      directionalLight.shadow = new THREE.LightShadow(new THREE.OrthographicCamera(-2, 2, 2, -2, 0.1, 5));
      directionalLight.shadow.mapSize.width = 4096;
      directionalLight.shadow.mapSize.height = 4096;
      directionalLight.shadow.bias = -0.002;
      this.add(directionalLight);
      return directionalLight;
    };

    Scene.prototype.showFrameSet = function(frameSet) {
      var frame, i, j, k, l, len, len1, len2, len3, ref, ref1, ref2, wireframe;
      if (frameSet == null) {
        frameSet = [];
      }
      ref = this._currentFrameSet;
      for (i = 0, len = ref.length; i < len; i++) {
        frame = ref[i];
        frame.mesh.visible = false;
      }
      for (j = 0, len1 = frameSet.length; j < len1; j++) {
        frame = frameSet[j];
        frame.mesh.visible = true;
      }
      wireframe = this.engine.renderingControls.wireframeControl.value;
      if (wireframe) {
        ref1 = this._currentFrameSet;
        for (k = 0, len2 = ref1.length; k < len2; k++) {
          frame = ref1[k];
          if ((ref2 = frame.wireframeMesh) != null) {
            ref2.visible = false;
          }
        }
        for (l = 0, len3 = frameSet.length; l < len3; l++) {
          frame = frameSet[l];
          this.generateWireframeMesh(frame);
          frame.wireframeMesh.visible = true;
        }
      }
      this._currentFrameSet = frameSet;
      return this.update();
    };

    Scene.prototype.addModel = function(model) {
      model.matrix = this.normalizationMatrix;
      this.add(model);
      this.update();
      this.sceneBoundingBox = this.sceneBoundingBox.union(model.boundingBox);
      this.updateScale();
      return this.updateTranslation();
    };

    Scene.prototype.addMesh = function(mesh) {
      return this.update();
    };

    Scene.prototype.update = function() {
      var i, len, mesh, meshName, model, ref, results;
      ref = this.children;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        model = ref[i];
        if (model instanceof TopViewer.Model) {
          results.push((function() {
            var ref1, results1;
            ref1 = model.meshes;
            results1 = [];
            for (meshName in ref1) {
              mesh = ref1[meshName];
              mesh.castShadow = this.engine.renderingControls.shadowsControl.value;
              mesh.receiveShadows = this.engine.renderingControls.shadowsControl.value;
              if (mesh.backsideMesh) {
                mesh.backsideMesh.castShadow = this.engine.renderingControls.shadowsControl.value;
                results1.push(mesh.backsideMesh.receiveShadows = this.engine.renderingControls.shadowsControl.value);
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          }).call(this));
        }
      }
      return results;
    };

    Scene.prototype.updateScale = function() {
      var relativeChange, scaleFactor, sceneBoundingBoxDiagonal;
      sceneBoundingBoxDiagonal = new THREE.Vector3().subVectors(this.sceneBoundingBox.max, this.sceneBoundingBox.min);
      scaleFactor = 2 / sceneBoundingBoxDiagonal.length();
      if (this._scaleFactor) {
        relativeChange = this._scaleFactor / scaleFactor;
        if (relativeChange < 1.5) {
          return;
        }
      }
      this._scaleFactor = scaleFactor;
      this.scaleMatrix.makeScale(scaleFactor, scaleFactor, scaleFactor);
      this._recomputeNormalizationMatrix();
      return this._updateFloor();
    };

    Scene.prototype.updateRotation = function() {
      this.rotationMatrix.copy(this.engine.objectRotation);
      return this._recomputeNormalizationMatrix();
    };

    Scene.prototype.updateTranslation = function() {
      var center, relativeChange;
      center = this.sceneBoundingBox.center().clone();
      if (this._centerDistance) {
        relativeChange = this._centerDistance / center.length();
        if ((0.5 < relativeChange && relativeChange < 1.5)) {
          return;
        }
      }
      this._centerDistance = center.length();
      center.negate();
      this.translationMatrix.makeTranslation(center.x, center.y, center.z);
      this._recomputeNormalizationMatrix();
      return this._updateFloor();
    };

    Scene.prototype._updateFloor = function() {
      var center, minY;
      center = this.sceneBoundingBox.center().clone();
      center.negate();
      minY = (this.sceneBoundingBox.min.y + center.y) * this._scaleFactor;
      return this.floor.position.y = minY - 0.001;
    };

    Scene.prototype._recomputeNormalizationMatrix = function() {
      this.normalizationMatrix.copy(this.rotationMatrix);
      this.normalizationMatrix.multiply(this.scaleMatrix);
      return this.normalizationMatrix.multiply(this.translationMatrix);
    };

    return Scene;

  })(THREE.Scene);

}).call(this);

//# sourceMappingURL=scene.js.map
