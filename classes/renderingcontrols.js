// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TopViewer.RenderingControls = (function(superClass) {
    extend(RenderingControls, superClass);

    RenderingControls.MeshSurfaceSides = {
      SingleFront: 'SingleFront',
      SingleBack: 'SingleBack',
      DoubleFast: 'DoubleFast',
      DoubleQuality: 'DoubleQuality'
    };

    RenderingControls.VertexColorsType = {
      Color: 'Color',
      Scalar: 'Scalar'
    };

    RenderingControls.DisplayMethodNameForCollection = {
      meshes: '_displayMesh',
      volumes: '_displayVolume',
      scalars: '_displayScalar',
      vectors: '_displayVector'
    };

    RenderingControls.prototype.updateClientObjects = function(data) {
      var clientId, clientLoadedObjects, collectionName, display, displayMethodName, object, objectName, objects, ref, results;
      if (data.clientId != null) {
        this.clientsLoadedObjects[data.clientId] = data.loadedObjects;
        if (window.isMaster) {
          return this.options.engine.options.app.broadcast('renderingControlsUpdateClientObjects', this.clientsLoadedObjects);
        }
      } else {
        this.clientsLoadedObjects = data;
        ref = this.loadedObjects;
        results = [];
        for (collectionName in ref) {
          objects = ref[collectionName];
          results.push((function() {
            var ref1, results1;
            results1 = [];
            for (objectName in objects) {
              object = objects[objectName];
              display = true;
              ref1 = this.clientsLoadedObjects;
              for (clientId in ref1) {
                clientLoadedObjects = ref1[clientId];
                if (!clientLoadedObjects[collectionName][objectName]) {
                  display = false;
                }
              }
              displayMethodName = this.constructor.DisplayMethodNameForCollection[collectionName];
              results1.push(this[displayMethodName](objectName, display));
            }
            return results1;
          }).call(this));
        }
        return results;
      }
    };

    RenderingControls.prototype._broadcastObjectsUpdate = function() {
      return this.options.engine.options.app.broadcast('renderingControlsUpdateClientObjects', {
        clientId: window.clientID,
        loadedObjects: this.clientsLoadedObjects[window.clientID]
      });
    };

    function RenderingControls(options) {
      var $gradientArea, $gradientPreview, $lightingArea, $meshesArea, $meshesIsolinesArea, $meshesSurfaceArea, $meshesWireframeArea, $volumesArea, $volumesIsosurfacesArea, $volumesWireframeArea, applyScrollOffset, customLight, found, gradient, gradientPreviewImage, i, j, len, len1, lightingPreset, ref, ref1, saveState, scrollOffset;
      this.options = options;
      RenderingControls.__super__.constructor.apply(this, arguments);
      this.scalarControls = [];
      this.vectorControls = [];
      this.loadedObjects = {
        meshes: {},
        volumes: {},
        scalars: {},
        vectors: {}
      };
      this.clientsLoadedObjects = {};
      this.clientsLoadedObjects[window.clientID] = {
        meshes: {},
        volumes: {},
        scalars: {},
        vectors: {}
      };
      this._broadcastObjectsUpdate();
      saveState = this.options.engine.options.app.state.renderingControls;
      this.$appWindow = this.options.engine.$appWindow;
      this.scene = this.options.engine.scene;
      this.$controls = $("<div class='rendering-controls'>");
      this.$appWindow.append(this.$controls);
      this.$rootElement = this.$controls;
      this.rootControl = new TopViewer.UIControl(this, this.$controls);
      scrollOffset = saveState.scrollOffset;
      applyScrollOffset = (function(_this) {
        return function() {
          return _this.$controls.css({
            top: -scrollOffset
          });
        };
      })(this);
      setTimeout(((function(_this) {
        return function() {
          return applyScrollOffset();
        };
      })(this)), 1);
      this.rootControl.scroll((function(_this) {
        return function(delta) {
          scrollOffset += delta;
          scrollOffset = Math.max(scrollOffset, 0);
          scrollOffset = Math.min(scrollOffset, _this.$controls.height() - _this.options.engine.$appWindow.height() * 0.8);
          saveState.scrollOffset = scrollOffset;
          return applyScrollOffset();
        };
      })(this));
      $lightingArea = $("<div class='lighting-area'></div>");
      new TopViewer.ToggleContainer(this, {
        $parent: this.$controls,
        text: "Lighting",
        "class": "panel",
        visible: saveState.lighting.panelEnabled,
        $contents: $lightingArea,
        onChange: (function(_this) {
          return function(value) {
            return saveState.lighting.panelEnabled = value;
          };
        })(this)
      });
      this.lightingSetupControl = new TopViewer.DropdownControl(this, {
        $parent: $lightingArea,
        "class": 'lighting-setup-dropdown',
        onChange: (function(_this) {
          return function(value, control) {
            return saveState.lighting.lightingSetup = {
              name: control.dropdownControl.options.text,
              value: value.lightDirection
            };
          };
        })(this)
      });
      ref = this.options.engine.lightingPresets;
      for (i = 0, len = ref.length; i < len; i++) {
        lightingPreset = ref[i];
        this.lightingSetupControl.addValue(lightingPreset.name, lightingPreset);
      }
      if (saveState.lighting.lightingSetup.name) {
        found = this.lightingSetupControl.setValue(saveState.lighting.lightingSetup.name);
        if (!found) {
          customLight = new LightingSetup(saveState.lightingSetup.name, saveState.lightingSetup.value);
          this.lightingSetupControl.setValueDirectly(customLight.name, customLight);
        }
      } else {
        this.lightingSetupControl.setValue(this.options.engine.lightingPresets[0]);
      }
      this.bidirectionalLightControl = new TopViewer.CheckboxControl(this, {
        $parent: $lightingArea,
        name: 'Bidirectional',
        value: saveState.lighting.bidirectional,
        "class": 'advanced',
        onChange: (function(_this) {
          return function(value) {
            return saveState.lighting.bidirectional = value;
          };
        })(this)
      });
      this.shadowsControl = new TopViewer.CheckboxControl(this, {
        $parent: $lightingArea,
        name: 'Cast shadows',
        value: saveState.lighting.shadows,
        onChange: (function(_this) {
          return function(value) {
            return saveState.lighting.shadows = value;
          };
        })(this)
      });
      $lightingArea.append("<p class='label'>Ambient light</p>");
      this.ambientLevelControl = new TopViewer.SliderControl(this, {
        $parent: $lightingArea,
        minimumValue: 0,
        maximumValue: 1,
        value: saveState.lighting.ambient,
        decimals: -2,
        onChange: (function(_this) {
          return function(value) {
            return saveState.lighting.ambient = value;
          };
        })(this)
      });
      $gradientArea = $("<div class='gradient-area'></div>");
      new TopViewer.ToggleContainer(this, {
        $parent: this.$controls,
        text: "Colors",
        "class": "panel",
        visible: saveState.gradient.panelEnabled,
        $contents: $gradientArea,
        onChange: (function(_this) {
          return function(value) {
            return saveState.gradient.panelEnabled = value;
          };
        })(this)
      });
      $gradientPreview = $("<div class='gradient-preview-area'><img class='gradient-preview-image'/></div>");
      gradientPreviewImage = $gradientPreview.find('img')[0];
      this.gradientControl = new TopViewer.DropdownControl(this, {
        $parent: $gradientArea,
        "class": 'gradient-dropdown',
        onChange: (function(_this) {
          return function(value) {
            gradientPreviewImage.src = value.url;
            saveState.gradient.name = value.name;
            return TopViewer.CurveTransformControl.drawSpectrogram();
          };
        })(this)
      });
      ref1 = this.options.engine.gradients;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        gradient = ref1[j];
        this.gradientControl.addValue(gradient.name, gradient);
      }
      found = false;
      if (saveState.gradient.name) {
        found = this.gradientControl.setValue(saveState.gradient.name);
      }
      if (!found) {
        this.gradientControl.setValue(this.options.engine.gradients[0]);
      }
      $gradientArea.append($gradientPreview);
      $meshesArea = $("<div class='meshes-area'></div>");
      new TopViewer.ToggleContainer(this, {
        $parent: this.$controls,
        text: "Meshes",
        "class": "panel",
        visible: saveState.meshes.panelEnabled,
        $contents: $meshesArea,
        onChange: (function(_this) {
          return function(value) {
            return saveState.meshes.panelEnabled = value;
          };
        })(this)
      });
      $meshesSurfaceArea = $("<div class='surface-area sub-panel first'><div class='title'>Surface</div></div>");
      $meshesArea.append($meshesSurfaceArea);
      this.meshesShowSurfaceControl = new TopViewer.CheckboxControl(this, {
        $parent: $meshesSurfaceArea,
        name: 'Enable',
        value: saveState.meshes.surfaceEnabled,
        onChange: (function(_this) {
          return function(value) {
            return saveState.meshes.surfaceEnabled = value;
          };
        })(this)
      });
      this.meshesSurfaceSidesControl = new TopViewer.DropdownControl(this, {
        $parent: $meshesSurfaceArea,
        "class": 'meshes-surface-sides-selector advanced',
        onChange: (function(_this) {
          return function(value) {
            return saveState.meshes.surfaceSides = value;
          };
        })(this)
      });
      this.meshesSurfaceSidesControl.addValue('Single Sided (front)', this.constructor.MeshSurfaceSides.SingleFront);
      this.meshesSurfaceSidesControl.addValue('Single Sided (back)', this.constructor.MeshSurfaceSides.SingleBack);
      this.meshesSurfaceSidesControl.addValue('Double Sided (fast)', this.constructor.MeshSurfaceSides.DoubleFast);
      this.meshesSurfaceSidesControl.addValue('Double Sided (quality)', this.constructor.MeshSurfaceSides.DoubleQuality);
      this.meshesSurfaceSidesControl.setValue(saveState.meshes.surfaceSides);
      this.meshesSurfaceColorsControl = new TopViewer.VertexColorsControl(this, {
        $parent: $meshesSurfaceArea,
        "class": 'meshes-surface-colors-selector',
        saveState: saveState.meshes.surfaceColors
      });
      $meshesSurfaceArea.append("<p class='label'>Opacity</p>");
      this.meshesSurfaceOpacityControl = new TopViewer.SliderControl(this, {
        $parent: $meshesSurfaceArea,
        minimumValue: 0,
        maximumValue: 1,
        value: saveState.meshes.surfaceOpacity,
        decimals: -2,
        onChange: (function(_this) {
          return function(value) {
            return saveState.meshes.surfaceOpacity = value;
          };
        })(this)
      });
      $meshesWireframeArea = $("<div class='wireframe-area sub-panel'><div class='title'>Wireframe</div></div>");
      $meshesArea.append($meshesWireframeArea);
      this.meshesShowWireframeControl = new TopViewer.CheckboxControl(this, {
        $parent: $meshesWireframeArea,
        name: 'Enable',
        value: saveState.meshes.wireframeEnabled,
        onChange: (function(_this) {
          return function(value) {
            return saveState.meshes.wireframeEnabled = value;
          };
        })(this)
      });
      this.meshesWireframeColorsControl = new TopViewer.VertexColorsControl(this, {
        $parent: $meshesWireframeArea,
        "class": 'meshes-wireframe-colors-selector',
        saveState: saveState.meshes.wireframeColors
      });
      $meshesWireframeArea.append("<p class='label'>Opacity</p>");
      this.meshesWireframeOpacityControl = new TopViewer.SliderControl(this, {
        $parent: $meshesWireframeArea,
        minimumValue: 0,
        maximumValue: 1,
        value: saveState.meshes.wireframeOpacity,
        decimals: -2,
        onChange: (function(_this) {
          return function(value) {
            return saveState.meshes.wireframeOpacity = value;
          };
        })(this)
      });
      $meshesIsolinesArea = $("<div class='isolines-area sub-panel'><div class='title'>Isolines</div></div>");
      $meshesArea.append($meshesIsolinesArea);
      this.meshesShowIsolinesControl = new TopViewer.CheckboxControl(this, {
        $parent: $meshesIsolinesArea,
        name: 'Enable',
        value: saveState.meshes.isolinesEnabled,
        onChange: (function(_this) {
          return function(value) {
            return saveState.meshes.isolinesEnabled = value;
          };
        })(this)
      });
      $meshesIsolinesArea.append("<p class='label'>Isovalues</p>");
      this.meshesIsolinesScalarControl = new TopViewer.ScalarControl(this, {
        $parent: $meshesIsolinesArea,
        saveState: saveState.meshes.isolinesScalar
      });
      $meshesIsolinesArea.append("<p class='label'>Line coloring</p>");
      this.meshesIsolinesColorsControl = new TopViewer.VertexColorsControl(this, {
        $parent: $meshesIsolinesArea,
        "class": 'meshes-isolines-colors-selector',
        saveState: saveState.meshes.isolinesColors
      });
      $meshesIsolinesArea.append("<p class='label'>Opacity</p>");
      this.meshesIsolinesOpacityControl = new TopViewer.SliderControl(this, {
        $parent: $meshesIsolinesArea,
        minimumValue: 0,
        maximumValue: 1,
        value: saveState.meshes.isolinesOpacity,
        decimals: -2,
        onChange: (function(_this) {
          return function(value) {
            return saveState.meshes.isolinesOpacity = value;
          };
        })(this)
      });
      this.$meshes = $("<ul class='meshes sub-panel'></ul>");
      $meshesArea.append(this.$meshes);
      $volumesArea = $("<div class='volumes-area'></div>");
      new TopViewer.ToggleContainer(this, {
        $parent: this.$controls,
        text: "Volumes",
        "class": "panel",
        visible: saveState.volumes.panelEnabled,
        $contents: $volumesArea,
        onChange: (function(_this) {
          return function(value) {
            return saveState.volumes.panelEnabled = value;
          };
        })(this)
      });
      $volumesWireframeArea = $("<div class='wireframe-area sub-panel'><div class='title'>Wireframe</div></div>");
      $volumesArea.append($volumesWireframeArea);
      this.volumesShowWireframeControl = new TopViewer.CheckboxControl(this, {
        $parent: $volumesWireframeArea,
        name: 'Enable',
        value: saveState.volumes.wireframeEnabled,
        onChange: (function(_this) {
          return function(value) {
            return saveState.volumes.wireframeEnabled = value;
          };
        })(this)
      });
      this.volumesWireframeColorsControl = new TopViewer.VertexColorsControl(this, {
        $parent: $volumesWireframeArea,
        "class": 'volumes-wireframe-colors-selector',
        saveState: saveState.volumes.wireframeColors
      });
      $volumesWireframeArea.append("<p class='label'>Opacity</p>");
      this.volumesWireframeOpacityControl = new TopViewer.SliderControl(this, {
        $parent: $volumesWireframeArea,
        minimumValue: 0,
        maximumValue: 1,
        value: saveState.volumes.wireframeOpacity,
        decimals: -2,
        onChange: (function(_this) {
          return function(value) {
            return saveState.volumes.wireframeOpacity = value;
          };
        })(this)
      });
      $volumesIsosurfacesArea = $("<div class='isosrufaces-area sub-panel'><div class='title'>Isosurfaces</div></div>");
      $volumesArea.append($volumesIsosurfacesArea);
      this.volumesShowIsosurfacesControl = new TopViewer.CheckboxControl(this, {
        $parent: $volumesIsosurfacesArea,
        name: 'Enable',
        value: saveState.volumes.isosurfacesEnabled,
        onChange: (function(_this) {
          return function(value) {
            return saveState.volumes.isosurfacesEnabled = value;
          };
        })(this)
      });
      $volumesIsosurfacesArea.append("<p class='label'>Isovalues</p>");
      this.volumesIsosurfacesScalarControl = new TopViewer.ScalarControl(this, {
        $parent: $volumesIsosurfacesArea,
        saveState: saveState.volumes.isosurfacesScalar
      });
      $volumesIsosurfacesArea.append("<p class='label'>Surface coloring</p>");
      this.volumesIsosurfacesColorsControl = new TopViewer.VertexColorsControl(this, {
        $parent: $volumesIsosurfacesArea,
        "class": 'volumes-isosurfaces-colors-selector',
        saveState: saveState.volumes.isosurfacesColors
      });
      $volumesIsosurfacesArea.append("<p class='label'>Opacity</p>");
      this.volumesIsosurfacesOpacityControl = new TopViewer.SliderControl(this, {
        $parent: $volumesIsosurfacesArea,
        minimumValue: 0,
        maximumValue: 1,
        value: saveState.volumes.isosurfacesOpacity,
        decimals: -2,
        onChange: (function(_this) {
          return function(value) {
            return saveState.volumes.isosurfacesOpacity = value;
          };
        })(this)
      });
      this.$volumes = $("<ul class='volumes sub-panel'></ul>");
      $volumesArea.append(this.$volumes);
      this.$scalarsArea = $("<ul class='scalars-area'></ul>");
      new TopViewer.ToggleContainer(this, {
        $parent: this.$controls,
        text: "Scalars",
        "class": "panel",
        visible: saveState.scalars.panelEnabled,
        $contents: this.$scalarsArea,
        onChange: (function(_this) {
          return function(value) {
            return saveState.scalars.panelEnabled = value;
          };
        })(this)
      });
      this.$vectorsArea = $("<div class='vectors-area'></div>");
      new TopViewer.ToggleContainer(this, {
        $parent: this.$controls,
        text: "Vectors",
        "class": "panel",
        visible: saveState.vectors.panelEnabled,
        $contents: this.$vectorsArea,
        onChange: (function(_this) {
          return function(value) {
            return saveState.vectors.panelEnabled = value;
          };
        })(this)
      });
      this.$vectorsDisplacementArea = $("<div class='vectors-displacement-area sub-panel'><div class='title'>Displacement</div></div>");
      this.$vectorsArea.append(this.$vectorsDisplacementArea);
      this.vectorsDisplacementVectorControl = new TopViewer.VectorControl(this, {
        $parent: this.$vectorsDisplacementArea,
        saveState: saveState.vectors.displacementVector,
        autoloadNameRegex: /disp/i
      });
      this.$vectorsDisplacementArea.append("<p class='label'>Amplification</p>");
      this.vectorsDisplacementFactorControl = new TopViewer.SliderControl(this, {
        $parent: this.$vectorsDisplacementArea,
        "class": 'vectors-displacement-factor',
        minimumValue: 0,
        maximumValue: 100,
        power: 4,
        decimals: -2,
        value: saveState.vectors.displacementFactor,
        onChange: (function(_this) {
          return function(value) {
            return saveState.displacementFactor = value;
          };
        })(this)
      });
      this.$vectorsFieldArea = $("<div class='vectors-field-area sub-panel'><div class='title'>Vector field</div></div>");
      this.$vectorsArea.append(this.$vectorsFieldArea);
      this.vectorsFieldVectorControl = new TopViewer.VectorControl(this, {
        $parent: this.$vectorsFieldArea,
        saveState: saveState.vectors.fieldVector
      });
      this.$vectorsFieldArea.append("<p class='label'>Unit length</p>");
      this.vectorsFieldLengthControl = new TopViewer.SliderControl(this, {
        $parent: this.$vectorsFieldArea,
        "class": 'vectors-field-length',
        minimumValue: 0,
        maximumValue: 0.1,
        power: 5,
        decimals: -5,
        value: saveState.vectors.fieldLength,
        onChange: (function(_this) {
          return function(value) {
            return saveState.vectors.fieldLength = value;
          };
        })(this)
      });
      this.vectorsFieldColorsControl = new TopViewer.VertexColorsControl(this, {
        $parent: this.$vectorsFieldArea,
        "class": 'vectors-field-colors-selector',
        saveState: saveState.vectors.fieldColors
      });
      this.$vectorsFieldArea.append("<p class='label'>Opacity</p>");
      this.vectorsFieldOpacityControl = new TopViewer.SliderControl(this, {
        $parent: this.$vectorsFieldArea,
        minimumValue: 0,
        maximumValue: 1,
        value: saveState.vectors.fieldOpacity,
        decimals: -2,
        onChange: (function(_this) {
          return function(value) {
            return saveState.vectors.fieldOpacity = value;
          };
        })(this)
      });
      this.initialize();
    }

    RenderingControls.prototype.addMesh = function(name, mesh) {
      var $contents, $mesh, saveState, states;
      $mesh = $("<li class='mesh'></li>").hide();
      this.loadedObjects.meshes[name] = {
        $element: $mesh
      };
      this._addObject(name, this.loadedObjects.meshes, this.$meshes);
      $contents = $("<div>");
      states = this.options.engine.options.app.state.renderingControls.meshes;
      saveState = TopViewer.SaveState.findStateForName(states, name);
      mesh.renderingControls = {
        showSurfaceControl: new TopViewer.CheckboxControl(this, {
          $parent: $contents,
          name: 'surface',
          parent: this.meshesShowSurfaceControl,
          value: saveState.surfaceEnabled,
          onChange: function(value) {
            return saveState.surfaceEnabled = value;
          }
        }),
        showWireframeControl: new TopViewer.CheckboxControl(this, {
          $parent: $contents,
          name: 'wireframe',
          parent: this.meshesShowWireframeControl,
          value: saveState.wireframeEnabled,
          onChange: function(value) {
            return saveState.wireframeEnabled = value;
          }
        }),
        showIsolinesControl: new TopViewer.CheckboxControl(this, {
          $parent: $contents,
          name: 'isolines',
          parent: this.meshesShowIsolinesControl,
          value: saveState.isolinesEnabled,
          onChange: function(value) {
            return saveState.isolinesEnabled = value;
          }
        })
      };
      new TopViewer.ToggleContainer(this, {
        $parent: $mesh,
        text: name,
        visible: false,
        $contents: $contents
      });
      this.clientsLoadedObjects[window.clientID].meshes[name] = true;
      return this._broadcastObjectsUpdate();
    };

    RenderingControls.prototype._displayMesh = function(name, visible) {
      return this.loadedObjects.meshes[name].$element.toggle(visible);
    };

    RenderingControls.prototype.addVolume = function(name, volume) {
      var $contents, $volume, saveState, states;
      $volume = $("<li class='volume'></li>").hide();
      this.loadedObjects.volumes[name] = {
        $element: $volume
      };
      this._addObject(name, this.loadedObjects.volumes, this.$volumes);
      $contents = $("<div>");
      states = this.options.engine.options.app.state.renderingControls.volumes;
      saveState = TopViewer.SaveState.findStateForName(states, name);
      volume.renderingControls = {
        showWireframeControl: new TopViewer.CheckboxControl(this, {
          $parent: $contents,
          name: 'wireframe',
          parent: this.volumesShowWireframeControl,
          value: saveState.wireframeEnabled,
          onChange: function(value) {
            return saveState.wireframeEnabled = value;
          }
        }),
        showIsosurfacesControl: new TopViewer.CheckboxControl(this, {
          $parent: $contents,
          name: 'isosurfaces',
          parent: this.volumesShowIsosurfacesControl,
          value: saveState.isosurfacesEnabled,
          onChange: function(value) {
            return saveState.isosurfacesEnabled = value;
          }
        })
      };
      new TopViewer.ToggleContainer(this, {
        $parent: $volume,
        text: name,
        visible: false,
        $contents: $contents
      });
      this.clientsLoadedObjects[window.clientID].volumes[name] = true;
      return this._broadcastObjectsUpdate();
    };

    RenderingControls.prototype._displayVolume = function(name, visible) {
      return this.loadedObjects.volumes[name].$element.toggle(visible);
    };

    RenderingControls.prototype.addScalar = function(name, scalar) {
      var $contents, $scalar, control, i, len, ref, states;
      $scalar = $("<li class='scalar'></li>").hide();
      this.loadedObjects.scalars[name] = {
        $element: $scalar,
        result: scalar
      };
      ref = this.scalarControls;
      for (i = 0, len = ref.length; i < len; i++) {
        control = ref[i];
        control.updateResults();
      }
      this._addObject(name, this.loadedObjects.scalars, this.$scalarsArea);
      $contents = $("<div>");
      new TopViewer.ToggleContainer(this, {
        $parent: $scalar,
        text: name,
        visible: true,
        $contents: $contents
      });
      states = this.options.engine.options.app.state.renderingControls.scalars;
      scalar.renderingControls = {
        curveTransformControl: new TopViewer.CurveTransformControl(this, {
          $parent: $contents,
          saveState: TopViewer.SaveState.findStateForName(states, name),
          scalar: scalar,
          gradientControl: this.gradientControl
        })
      };
      this.clientsLoadedObjects[window.clientID].scalars[name] = true;
      return this._broadcastObjectsUpdate();
    };

    RenderingControls.prototype._displayScalar = function(name, visible) {
      var control, i, len, ref, results;
      this.loadedObjects.scalars[name].$element.toggle(visible);
      ref = this.scalarControls;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        control = ref[i];
        results.push(control.displayResult(name, visible));
      }
      return results;
    };

    RenderingControls.prototype.addVector = function(name, vector) {
      var control, i, len, ref;
      this.loadedObjects.vectors[name] = {
        result: vector
      };
      ref = this.vectorControls;
      for (i = 0, len = ref.length; i < len; i++) {
        control = ref[i];
        control.updateResults();
      }
      this.clientsLoadedObjects[window.clientID].vectors[name] = true;
      return this._broadcastObjectsUpdate();
    };

    RenderingControls.prototype._displayVector = function(name, visible) {
      var control, i, len, ref, results;
      ref = this.vectorControls;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        control = ref[i];
        results.push(control.displayResult(name, visible));
      }
      return results;
    };

    RenderingControls.prototype._addObject = function(name, objects, $targetArea) {
      var $element, index, names;
      names = _.keys(objects).sort();
      index = _.indexOf(names, name);
      $element = objects[name].$element;
      if (index > 0) {
        return $element.insertAfter(objects[names[index - 1]].$element);
      } else {
        return $targetArea.prepend($element);
      }
    };

    RenderingControls.prototype.onMouseDown = function(position, button) {
      RenderingControls.__super__.onMouseDown.apply(this, arguments);
      return TopViewer.CurveTransformControl.mouseDown(this.transformPositionToPage(position));
    };

    RenderingControls.prototype.onMouseMove = function(position) {
      RenderingControls.__super__.onMouseMove.apply(this, arguments);
      return TopViewer.CurveTransformControl.mouseMove(this.transformPositionToPage(position));
    };

    RenderingControls.prototype.onMouseUp = function(position, button) {
      RenderingControls.__super__.onMouseUp.apply(this, arguments);
      return TopViewer.CurveTransformControl.mouseUp(this.transformPositionToPage(position));
    };

    RenderingControls.prototype.transformPositionToPage = function(position) {
      var offset;
      offset = this.$appWindow.offset();
      return {
        x: position.x + offset.left,
        y: position.y + offset.top
      };
    };

    return RenderingControls;

  })(TopViewer.UIArea);

}).call(this);

//# sourceMappingURL=renderingcontrols.js.map
