// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TopViewer.IsosurfaceMaterial = (function(superClass) {
    extend(IsosurfaceMaterial, superClass);

    function IsosurfaceMaterial(model) {
      this.model = model;
      IsosurfaceMaterial.__super__.constructor.call(this, {
        uniforms: {
          basePositionsTexture: {
            type: 't',
            value: this.model.basePositionsTexture
          },
          displacementsTexture: {
            type: 't',
            value: this.model.displacementsTexture
          },
          displacementFactor: {
            type: 'f',
            value: 0
          },
          scalarsTexture: {
            type: 't',
            value: this.model.scalarsTexture
          },
          scalarsMin: {
            type: 'f',
            value: 0
          },
          scalarsRange: {
            type: 'f',
            value: 0
          },
          gradientTexture: {
            type: 't',
            value: this.model.options.engine.gradientTexture
          },
          gradientCurveTexture: {
            type: 't',
            value: this.model.options.engine.gradientCurveTexture
          },
          time: {
            type: 'f',
            value: 0
          },
          color: {
            type: 'c',
            value: new THREE.Color('white')
          },
          opacity: {
            type: 'f',
            value: 0.5
          }
        },
        side: THREE.DoubleSide,
        vertexShader: "precision highp float;\nprecision highp int;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform sampler2D basePositionsTexture;\n\nuniform sampler2D displacementsTexture;\nuniform float displacementFactor;\n\nuniform sampler2D scalarsTexture;\nuniform float scalarsMin;\nuniform float scalarsRange;\n\nuniform sampler2D gradientCurveTexture;\n\nuniform float time;\n\nattribute vec2 vertex1Index;\nattribute vec2 vertex2Index;\nattribute vec2 vertex3Index;\nattribute vec2 vertex4Index;\nattribute float vertexType;\n\nvarying float scalar;\n\nconst float isostep = 0.1;\n\nvoid main()	{\n  scalar = -1.0;\n\n  if (scalarsRange > 0.0) {\n    vec3 vertex1Position = texture2D(basePositionsTexture, vertex1Index).xyz;\n    vec3 vertex2Position = texture2D(basePositionsTexture, vertex2Index).xyz;\n    vec3 vertex3Position = texture2D(basePositionsTexture, vertex3Index).xyz;\n    vec3 vertex4Position = texture2D(basePositionsTexture, vertex4Index).xyz;\n\n    if (displacementFactor > 0.0) {\n      vertex1Position += texture2D(displacementsTexture, vertex1Index).xyz * displacementFactor;\n      vertex2Position += texture2D(displacementsTexture, vertex2Index).xyz * displacementFactor;\n      vertex3Position += texture2D(displacementsTexture, vertex3Index).xyz * displacementFactor;\n      vertex4Position += texture2D(displacementsTexture, vertex4Index).xyz * displacementFactor;\n    }\n\n    float scalar1 = clamp((texture2D(scalarsTexture, vertex1Index).a - scalarsMin) / scalarsRange, 0.01, 0.99);\n    float scalar2 = clamp((texture2D(scalarsTexture, vertex2Index).a - scalarsMin) / scalarsRange, 0.01, 0.99);\n    float scalar3 = clamp((texture2D(scalarsTexture, vertex3Index).a - scalarsMin) / scalarsRange, 0.01, 0.99);\n    float scalar4 = clamp((texture2D(scalarsTexture, vertex4Index).a - scalarsMin) / scalarsRange, 0.01, 0.99);\n    float curvedScalar1 = texture2D(gradientCurveTexture, vec2(scalar1, 0)).a;\n    float curvedScalar2 = texture2D(gradientCurveTexture, vec2(scalar2, 0)).a;\n    float curvedScalar3 = texture2D(gradientCurveTexture, vec2(scalar3, 0)).a;\n    float curvedScalar4 = texture2D(gradientCurveTexture, vec2(scalar4, 0)).a;\n\n    for (float isovalue=0.0;isovalue<1.0;isovalue+=isostep) {\n      bool above1 = curvedScalar1 > isovalue;\n      bool above2 = curvedScalar2 > isovalue;\n      bool above3 = curvedScalar3 > isovalue;\n      bool above4 = curvedScalar4 > isovalue;\n      int aboveCount = 0;\n      if (above1) aboveCount++;\n      if (above2) aboveCount++;\n      if (above3) aboveCount++;\n      if (above4) aboveCount++;\n\n      if (aboveCount==0 || aboveCount==4) {\n        continue;\n      } else {\n        vec3 leftPosition;\n        vec3 rightPosition;\n        float leftScalar;\n        float rightScalar;\n\n        if (aboveCount==2) {\n          // Case with two triangles.\n          if (vertexType < 0.05) {\n            // Vertex 1\n            if (above1 != above2) {\n              leftPosition = vertex1Position;\n              rightPosition =vertex2Position;\n              leftScalar = curvedScalar1;\n              rightScalar = curvedScalar2;\n            } else {\n              leftPosition = vertex1Position;\n              rightPosition =vertex3Position;\n              leftScalar = curvedScalar1;\n              rightScalar = curvedScalar3;\n            }\n          } else if (vertexType < 0.15) {\n            // Vertex 2\n            if (above2 != above4) {\n              leftPosition = vertex2Position;\n              rightPosition =vertex4Position;\n              leftScalar = curvedScalar2;\n              rightScalar = curvedScalar4;\n            } else {\n              leftPosition = vertex2Position;\n              rightPosition =vertex3Position;\n              leftScalar = curvedScalar2;\n              rightScalar = curvedScalar3;\n            }\n          } else if (vertexType < 0.25) {\n            // Vertex 3\n            if (above1 != above4) {\n              leftPosition = vertex1Position;\n              rightPosition =vertex4Position;\n              leftScalar = curvedScalar1;\n              rightScalar = curvedScalar4;\n            } else {\n              leftPosition = vertex1Position;\n              rightPosition =vertex3Position;\n              leftScalar = curvedScalar1;\n              rightScalar = curvedScalar3;\n            }\n          } else if (vertexType < 0.35) {\n            // Vertex extra 1\n            if (above1 != above3) {\n              leftPosition = vertex1Position;\n              rightPosition =vertex3Position;\n              leftScalar = curvedScalar1;\n              rightScalar = curvedScalar3;\n            } else {\n              leftPosition = vertex1Position;\n              rightPosition =vertex4Position;\n              leftScalar = curvedScalar1;\n              rightScalar = curvedScalar4;\n            }\n          } else if (vertexType < 0.45) {\n            // Vertex extra 2\n            if (above2 != above3) {\n              leftPosition = vertex2Position;\n              rightPosition =vertex3Position;\n              leftScalar = curvedScalar2;\n              rightScalar = curvedScalar3;\n            } else {\n              leftPosition = vertex2Position;\n              rightPosition =vertex4Position;\n              leftScalar = curvedScalar2;\n              rightScalar = curvedScalar4;\n            }\n          } else {\n            // Vertex extra 3\n            if (above3 != above4) {\n              leftPosition = vertex3Position;\n              rightPosition =vertex4Position;\n              leftScalar = curvedScalar3;\n              rightScalar = curvedScalar4;\n            } else {\n              leftPosition = vertex2Position;\n              rightPosition =vertex4Position;\n              leftScalar = curvedScalar2;\n              rightScalar = curvedScalar4;\n            }\n          }\n        } else {\n          // Case with one triangle. Skip for second triangle.\n          if (vertexType > 0.25) continue;\n\n          if (vertexType < 0.05) {\n            // Vertex 1\n            if (above1 != above2) {\n              leftPosition = vertex1Position;\n              rightPosition =vertex2Position;\n              leftScalar = curvedScalar1;\n              rightScalar = curvedScalar2;\n            } else if (above1 != above3) {\n              leftPosition = vertex1Position;\n              rightPosition =vertex3Position;\n              leftScalar = curvedScalar1;\n              rightScalar = curvedScalar3;\n            } else {\n              leftPosition = vertex1Position;\n              rightPosition =vertex4Position;\n              leftScalar = curvedScalar1;\n              rightScalar = curvedScalar4;\n            }\n          } else if (vertexType < 0.15) {\n            // Vertex 2\n            if (above2 != above3) {\n              leftPosition = vertex2Position;\n              rightPosition =vertex3Position;\n              leftScalar = curvedScalar2;\n              rightScalar = curvedScalar3;\n            } else if (above2 != above4) {\n              leftPosition = vertex2Position;\n              rightPosition =vertex4Position;\n              leftScalar = curvedScalar2;\n              rightScalar = curvedScalar4;\n            } else {\n              leftPosition = vertex1Position;\n              rightPosition =vertex3Position;\n              leftScalar = curvedScalar1;\n              rightScalar = curvedScalar3;\n            }\n          } else {\n            // Vertex 3\n            if (above3 != above4) {\n              leftPosition = vertex3Position;\n              rightPosition =vertex4Position;\n              leftScalar = curvedScalar3;\n              rightScalar = curvedScalar4;\n            } else if (above2 != above4) {\n              leftPosition = vertex2Position;\n              rightPosition =vertex4Position;\n              leftScalar = curvedScalar2;\n              rightScalar = curvedScalar4;\n            } else {\n              leftPosition = vertex1Position;\n              rightPosition =vertex4Position;\n              leftScalar = curvedScalar1;\n              rightScalar = curvedScalar4;\n            }\n          }\n        }\n\n        // Make sure the lower value is on the left.\n        if (leftScalar > rightScalar) {\n          float tempScalar = leftScalar;\n          vec3 tempPosition = leftPosition;\n          leftScalar = rightScalar;\n          leftPosition = rightPosition;\n          rightScalar = tempScalar;\n          rightPosition = tempPosition;\n        }\n\n        float range = rightScalar - leftScalar;\n        float p = (isovalue - leftScalar) / range;\n        vec3 vertexPosition = mix(leftPosition, rightPosition, p);\n        scalar = mix(leftScalar, rightScalar, p);\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);\n        return;\n      }\n    }\n  }\n\n  gl_Position = vec4(0,0,0,1);\n  scalar = -1.0;\n}",
        fragmentShader: "precision highp float;\nprecision highp int;\n\nuniform sampler2D gradientTexture;\n\nuniform float time;\nuniform vec3 color;\nuniform float opacity;\n\nvarying float scalar;\n\nvoid main()	{\n  if (scalar >= 0.0) {\n    gl_FragColor = vec4(texture2D(gradientTexture, vec2(scalar, 0)).rgb, opacity);\n  } else {\n    gl_FragColor = vec4(color, opacity);\n  }\n}"
      });
    }

    return IsosurfaceMaterial;

  })(THREE.RawShaderMaterial);

}).call(this);

//# sourceMappingURL=isosurfacematerial.js.map
