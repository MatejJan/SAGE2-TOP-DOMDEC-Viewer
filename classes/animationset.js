// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TopViewer.AnimationSet = (function(superClass) {
    extend(AnimationSet, superClass);

    function AnimationSet(options) {
      this.options = options;
      AnimationSet.__super__.constructor.apply(this, arguments);
      this.loader = new THREE.TopLoader(this.options.loadingManager);
      this.files = [];
      this.objects = {
        nodes: {},
        elements: {},
        vectors: {},
        scalars: {}
      };
      this.times = [];
      this.meshes = {};
      this.loadGradient(this.options.resourcesPath + 'gradients/xpost.png');
    }

    AnimationSet.prototype.loadGradient = function(url) {
      var image;
      image = new Image();
      image.onload = (function(_this) {
        return function() {
          var canvas, i, k, ref, results, uintData;
          canvas = document.createElement('canvas');
          canvas.width = image.width;
          canvas.height = 1;
          canvas.getContext('2d').drawImage(image, 0, 0, image.width, 1);
          uintData = canvas.getContext('2d').getImageData(0, 0, image.width, 1).data;
          _this.gradientData = new Float32Array(uintData.length);
          results = [];
          for (i = k = 0, ref = uintData.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            results.push(_this.gradientData[i] = uintData[i] / 255);
          }
          return results;
        };
      })(this);
      return image.src = url;
    };

    AnimationSet.prototype.getFrameSet = function(frameIndex) {
      var frame, frameSet, mesh, nodesName, ref, time;
      time = this.times[frameIndex];
      frameSet = [];
      ref = this.meshes;
      for (nodesName in ref) {
        mesh = ref[nodesName];
        frame = mesh.getFrame(time);
        if (frame) {
          frameSet.push(frame);
        }
      }
      return frameSet;
    };

    AnimationSet.prototype.normalizeMeshes = function(forceNormalize, targetFrameSet) {
      var mesh, nodesName, ref, results;
      if (targetFrameSet) {
        return AnimationSet.__super__.normalizeMeshes.call(this, forceNormalize, targetFrameSet, this.referenceMesh);
      } else {
        ref = this.meshes;
        results = [];
        for (nodesName in ref) {
          mesh = ref[nodesName];
          console.log("norm", this.meshes);
          results.push(mesh.normalizeMeshes(forceNormalize, targetFrameSet, this.referenceMesh));
        }
        return results;
      }
    };

    AnimationSet.prototype.load = function() {
      var file, filename, k, len, ref;
      this.options.playbackControls.load();
      ref = this.options.filenames;
      for (k = 0, len = ref.length; k < len; k++) {
        filename = ref[k];
        file = {
          loaded: false,
          loadPercentage: 0,
          filename: filename
        };
        this.files.push(file);
      }
      this._nextFileToLoad = 0;
      this._filesLoaded = 0;
      this._concurentFramesLoading = 0;
      return this.processLoadQueue();
    };

    AnimationSet.prototype.processLoadQueue = function() {
      var file;
      if (this._nextFileToLoad == null) {
        return;
      }
      if (!this.options.playbackControls.loading) {
        return;
      }
      if (this._nextFileToLoad >= this.files.length) {
        return;
      }
      if (this.maxConcurrentFramesLoading && this._concurentFramesLoading >= this.maxConcurrentFramesLoading) {
        return;
      }
      file = this.files[this._nextFileToLoad];
      console.log("Loading", file.filename, this.loader);
      this.loader.load(file.filename, (function(_this) {
        return function(objects) {
          var base, base1, elementsInstance, elementsName, nodesInstance, nodesName, ref, ref1, ref2, ref3, scalar, scalarName, scalarNodesName, scalars, vector, vectorName, vectorNodesName, vectors;
          _this._filesLoaded++;
          ref = objects.nodes;
          for (nodesName in ref) {
            nodesInstance = ref[nodesName];
            _this.objects.nodes[nodesName] = nodesInstance;
          }
          ref1 = objects.elements;
          for (elementsName in ref1) {
            elementsInstance = ref1[elementsName];
            _this.objects.elements[elementsName] = elementsInstance;
          }
          ref2 = objects.scalars;
          for (scalarNodesName in ref2) {
            scalars = ref2[scalarNodesName];
            if ((base = _this.objects.scalars)[scalarNodesName] == null) {
              base[scalarNodesName] = {};
            }
            for (scalarName in scalars) {
              scalar = scalars[scalarName];
              _this.objects.scalars[scalarNodesName][scalarName] = scalar;
            }
          }
          ref3 = objects.vectors;
          for (vectorNodesName in ref3) {
            vectors = ref3[vectorNodesName];
            if ((base1 = _this.objects.vectors)[vectorNodesName] == null) {
              base1[vectorNodesName] = {};
            }
            for (vectorName in vectors) {
              vector = vectors[vectorName];
              _this.objects.vectors[vectorNodesName][vectorName] = vector;
            }
          }
          if (_this._filesLoaded === _this.files.length) {
            _this.processObjects();
          }
          _this._concurentFramesLoading--;
          return _this.processLoadQueue();
        };
      })(this), (function(_this) {
        return function(loadPercentage) {};
      })(this));
      this._nextFileToLoad++;
      this._concurentFramesLoading++;
      return this.processLoadQueue();
    };

    AnimationSet.prototype.processObjects = function() {
      var elementsInstance, elementsName, frame, k, len, limits, mesh, nodesInstance, nodesName, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, scalar, scalarName, scalarNodesName, scalars, vector, vectorName, vectorNodesName, vectors;
      console.log("PROCESSING OBJECTS!", this.options, this.objects);
      ref = this.objects.nodes;
      for (nodesName in ref) {
        nodesInstance = ref[nodesName];
        this.meshes[nodesName] = new this.constructor.Mesh(nodesName, nodesInstance, this);
      }
      ref1 = this.objects.elements;
      for (elementsName in ref1) {
        elementsInstance = ref1[elementsName];
        this.meshes[elementsInstance.nodesName].addElements(elementsName, elementsInstance);
      }
      limits = {};
      ref2 = this.objects.scalars;
      for (scalarNodesName in ref2) {
        scalars = ref2[scalarNodesName];
        for (scalarName in scalars) {
          scalar = scalars[scalarName];
          if (limits[scalarName] == null) {
            limits[scalarName] = {};
          }
          ref3 = scalar.frames;
          for (k = 0, len = ref3.length; k < len; k++) {
            frame = ref3[k];
            if (!((limits[scalarName].minValue != null) && limits[scalarName].minValue < frame.minValue)) {
              limits[scalarName].minValue = frame.minValue;
            }
            if (!((limits[scalarName].maxValue != null) && limits[scalarName].maxValue > frame.maxValue)) {
              limits[scalarName].maxValue = frame.maxValue;
            }
          }
        }
      }
      ref4 = this.objects.scalars;
      for (scalarNodesName in ref4) {
        scalars = ref4[scalarNodesName];
        for (scalarName in scalars) {
          scalar = scalars[scalarName];
          scalar.minValue = limits[scalarName].minValue;
          scalar.maxValue = limits[scalarName].maxValue;
          this.meshes[scalarNodesName].addScalar(scalarName, scalar);
        }
      }
      ref5 = this.objects.vectors;
      for (vectorNodesName in ref5) {
        vectors = ref5[vectorNodesName];
        for (vectorName in vectors) {
          vector = vectors[vectorName];
          this.meshes[vectorNodesName].addVector(vectorName, vector);
        }
      }
      this.referenceMesh = null;
      ref6 = this.meshes;
      for (nodesName in ref6) {
        mesh = ref6[nodesName];
        mesh.createFrames();
        mesh.normalizeMeshes();
        if (!this.referenceMesh && ((ref7 = mesh.frames[0]) != null ? ref7.normalized : void 0)) {
          this.referenceMesh = mesh;
          console.log("Set reference mesh to", this.referenceMesh);
        }
      }
      ref8 = this.meshes;
      for (nodesName in ref8) {
        mesh = ref8[nodesName];
        mesh.normalizeMeshes(true, null, this.referenceMesh);
      }
      this.times = [];
      ref9 = this.meshes;
      for (nodesName in ref9) {
        mesh = ref9[nodesName];
        this.times = _.union(this.times, mesh.times);
      }
      this.times.sort(function(a, b) {
        return a - b;
      });
      this.times = _.without(this.times, -1);
      if (!this.times.length) {
        this.times.push(-1);
      }
      this.length = this.times.length;
      console.log("We have an animation of", this.length, "length and times", this.times);
      this.ready = true;
      return this.readyLength = this.length;
    };

    AnimationSet.Mesh = (function(superClass1) {
      extend(Mesh, superClass1);

      function Mesh(nodesName1, nodesInstance1, animation) {
        this.nodesName = nodesName1;
        this.nodesInstance = nodesInstance1;
        this.animation = animation;
        Mesh.__super__.constructor.call(this, this.animation.options);
        this.elements = {};
        this.scalars = {};
        this.vectors = {};
        this._currentScalarFrame = null;
        this._gradientMap = [];
        this._gradientMapLastUpdate = null;
        this._currentDisplacementFactor = null;
        this._currentPositions = null;
        this._paintedWhite = false;
      }

      Mesh.prototype.addElements = function(elementsName, elementsInstance) {
        return this.elements[elementsName] = elementsInstance;
      };

      Mesh.prototype.addScalar = function(scalarName, scalar) {
        return this.scalars[scalarName] = scalar;
      };

      Mesh.prototype.addVector = function(vectorName, vector) {
        return this.vectors[vectorName] = vector;
      };

      Mesh.prototype.getFrame = function(frameTime) {
        var colors, displacedPositions, frame, frameIndex, gradientIndex, i, k, l, m, mustRepaint, n, normalizeFactor, normalizedValue, o, offset, p, positions, ref, ref1, ref2, ref3, ref4, scalarFrame, testFrame, time, value, vectorFrame;
        frame = null;
        for (frameIndex = k = 1, ref = this.frames.length; 1 <= ref ? k < ref : k > ref; frameIndex = 1 <= ref ? ++k : --k) {
          testFrame = this.frames[frameIndex];
          if (!testFrame) {
            continue;
          }
          time = testFrame.time;
          if (time === frameTime || time === -1) {
            frame = testFrame;
          }
        }
        if (!frame) {
          return;
        }
        if (!(frame && frame.positions.length)) {
          return;
        }
        positions = frame.positions;
        displacedPositions = frame.displacedPositions;
        colors = frame.colors;
        scalarFrame = frame.scalarFrame;
        vectorFrame = frame.vectorFrame;
        if (scalarFrame && this.animation.gradientData) {
          mustRepaint = this._paintedWhite || this._currentScalarFrame !== scalarFrame;
          if (this._gradientMapLastUpdate !== this.animation.options.renderingControls.gradientCurve.lastUpdated) {
            this._gradientMapLastUpdate = this.animation.options.renderingControls.gradientCurve.lastUpdated;
            mustRepaint = true;
            'for i in [0..100]\n  normalizedValue = i/100\n\n  # Remap the value based on the gradient curve.\n  normalizedValue = @animation.options.renderingControls.gradientCurve.getY normalizedValue\n\n  # Set the gradient index into the map.\n  @_gradientMap[i] = Math.floor((@animation.gradientData.length / 4 - 1) * normalizedValue) * 4\n\nconsole.log "recreated gradient", @_gradientMap';
          }
          if (mustRepaint) {
            normalizeFactor = 1 / (frame.scalarMaxValue - frame.scalarMinValue);
            for (i = l = 0, ref1 = scalarFrame.scalars.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
              value = scalarFrame.scalars[i];
              normalizedValue = (value - frame.scalarMinValue) * normalizeFactor;
              normalizedValue = this.animation.options.renderingControls.gradientCurve.getY(normalizedValue);
              gradientIndex = Math.floor((this.animation.gradientData.length / 4 - 1) * normalizedValue) * 4;
              for (offset = m = 0; m <= 2; offset = ++m) {
                colors[i * 3 + offset] = this.animation.gradientData[gradientIndex + offset];
              }
            }
            this._paintedWhite = false;
            this._currentScalarFrame = scalarFrame;
            this.geometry.attributes.color.needsUpdate = true;
          }
        } else {
          if (!this._paintedWhite) {
            for (i = n = 0, ref2 = colors.length; 0 <= ref2 ? n < ref2 : n > ref2; i = 0 <= ref2 ? ++n : --n) {
              colors[i] = 1;
            }
            this._paintedWhite = true;
            this.geometry.attributes.color.needsUpdate = true;
          }
        }
        if (vectorFrame) {
          if (!(this._currentDisplacementFactor === this.animation.options.renderingControls.displacementFactor && this._currentPositions === positions)) {
            this._currentPositions = positions;
            for (i = o = 0, ref3 = positions.length; 0 <= ref3 ? o < ref3 : o > ref3; i = 0 <= ref3 ? ++o : --o) {
              displacedPositions[i] = positions[i] + vectorFrame.vectors[i] * this.animation.options.renderingControls.displacementFactor;
            }
          }
        } else {
          if (this._currentPositions !== positions) {
            this._currentPositions = positions;
            for (i = p = 0, ref4 = positions.length; 0 <= ref4 ? p < ref4 : p > ref4; i = 0 <= ref4 ? ++p : --p) {
              displacedPositions[i] = positions[i];
            }
          }
        }
        this.geometry.attributes.position.needsUpdate = true;
        this.geometry.computeVertexNormals();
        this.geometry.computeBoundingSphere();
        this.geometry.computeBoundingBox();
        return this.frames[1];
      };

      Mesh.prototype.createFrames = function() {
        var colors, displacedPositions, elementsInstance, elementsName, frame, i, indices, indicesCount, indicesOffset, j, k, l, len, len1, len2, len3, m, n, newFrame, o, p, positions, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, scalar, scalarFrame, scalarName, time, totalIndices, vector, vectorFrame, vectorName;
        this.times = [];
        ref = this.scalars;
        for (scalarName in ref) {
          scalar = ref[scalarName];
          ref1 = scalar.frames;
          for (k = 0, len = ref1.length; k < len; k++) {
            frame = ref1[k];
            this.times = _.union(this.times, [parseFloat(frame.time)]);
          }
        }
        ref2 = this.vectors;
        for (vectorName in ref2) {
          vector = ref2[vectorName];
          ref3 = vector.frames;
          for (l = 0, len1 = ref3.length; l < len1; l++) {
            frame = ref3[l];
            this.times = _.union(this.times, [parseFloat(frame.time)]);
          }
        }
        this.times.sort(function(a, b) {
          return a - b;
        });
        if (!this.times.length) {
          this.times.push(-1);
        }
        this.length = this.times.length;
        positions = this.nodesInstance.nodes;
        totalIndices = 0;
        ref4 = this.elements;
        for (elementsName in ref4) {
          elementsInstance = ref4[elementsName];
          totalIndices += elementsInstance.elements.length;
        }
        if (totalIndices) {
          indices = new Uint32Array(totalIndices);
          indicesOffset = 0;
          ref5 = this.elements;
          for (elementsName in ref5) {
            elementsInstance = ref5[elementsName];
            indicesCount = elementsInstance.elements.length;
            for (j = m = 0, ref6 = indicesCount; 0 <= ref6 ? m < ref6 : m > ref6; j = 0 <= ref6 ? ++m : --m) {
              indices[indicesOffset + j] = elementsInstance.elements[j];
            }
            indicesOffset += indicesCount;
          }
        }
        this.baseGeometry = new THREE.BufferGeometry();
        this.baseGeometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
        if (totalIndices) {
          this.baseGeometry.setIndex(new THREE.BufferAttribute(indices, 1));
        }
        this.baseGeometry.computeVertexNormals();
        this.baseGeometry.computeBoundingSphere();
        this.baseGeometry.computeBoundingBox();
        this.baseMesh = new THREE.Mesh(this.baseGeometry, this.animation.options.scene.modelMaterial);
        this.baseMesh.matrixAutoUpdate = false;
        this.baseFrame = {
          mesh: this.baseMesh,
          loaded: true,
          ready: true
        };
        this.frames.push(this.baseFrame);
        displacedPositions = positions.slice(0);
        colors = new Float32Array(positions.length);
        this.geometry = new THREE.BufferGeometry();
        this.geometry.addAttribute('position', new THREE.BufferAttribute(displacedPositions, 3));
        this.geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
        if (totalIndices) {
          this.geometry.setIndex(new THREE.BufferAttribute(indices, 1));
        }
        this.geometry.computeVertexNormals();
        this.geometry.computeBoundingSphere();
        this.geometry.computeBoundingBox();
        this.mesh = new THREE.Mesh(this.geometry, this.animation.options.scene.modelMaterial);
        this.mesh.matrixAutoUpdate = false;
        this.mesh.castShadow = true;
        ref7 = this.times;
        for (n = 0, len2 = ref7.length; n < len2; n++) {
          time = ref7[n];
          newFrame = {
            mesh: this.mesh,
            time: time,
            positions: positions,
            displacedPositions: displacedPositions,
            colors: colors,
            loaded: true,
            ready: true,
            normalized: true
          };
          ref8 = this.scalars;
          for (scalarName in ref8) {
            scalar = ref8[scalarName];
            for (i = o = 0, ref9 = scalar.frames.length; 0 <= ref9 ? o < ref9 : o > ref9; i = 0 <= ref9 ? ++o : --o) {
              scalarFrame = scalar.frames[i];
              if (time !== scalarFrame.time) {
                continue;
              }
              newFrame.scalarFrame = scalarFrame;
              newFrame.scalarMinValue = scalar.minValue;
              newFrame.scalarMaxValue = scalar.maxValue;
            }
          }
          ref10 = this.vectors;
          for (vectorName in ref10) {
            vector = ref10[vectorName];
            ref11 = vector.frames;
            for (p = 0, len3 = ref11.length; p < len3; p++) {
              vectorFrame = ref11[p];
              if (time !== vectorFrame.time) {
                continue;
              }
              newFrame.vectorFrame = vectorFrame;
            }
          }
          this.frames.push(newFrame);
        }
        this.frames[1].normalized = false;
        this.animation.options.scene.addFrame(this.frames[1]);
        this.ready = true;
        this.readyLength = this.length;
        if (this.onUpdated) {
          return this.onUpdated();
        }
      };

      return Mesh;

    })(TopViewer.Animation);

    return AnimationSet;

  })(TopViewer.Animation);

}).call(this);

//# sourceMappingURL=animationset.js.map
