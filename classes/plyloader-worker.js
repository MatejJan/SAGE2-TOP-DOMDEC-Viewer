// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var PLYWorker;

  importScripts('../libraries/three.min.js');

  self.onmessage = function(message) {
    var loader, url;
    url = message.data.url;
    loader = new THREE.XHRLoader(this.manager);
    loader.setCrossOrigin(message.data.crossOrigin);
    loader.setResponseType('arraybuffer');
    return loader.load(url, (function(_this) {
      return function(text) {
        var worker;
        worker = new PLYWorker(message.data.propertyNameMapping);
        postMessage({
          type: 'result',
          buffers: worker.parse(text)
        });
        return close();
      };
    })(this));
  };

  PLYWorker = (function() {
    function PLYWorker(propertyNameMapping1) {
      this.propertyNameMapping = propertyNameMapping1;
    }

    PLYWorker.prototype.bin2str = function(buf) {
      var array_buffer, i, k, ref, str;
      array_buffer = new Uint8Array(buf);
      str = '';
      for (i = k = 0, ref = buf.byteLength; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        str += String.fromCharCode(array_buffer[i]);
      }
      return str;
    };

    PLYWorker.prototype.isASCII = function(header) {
      return header.format === 'ascii';
    };

    PLYWorker.prototype.parse = function(data) {
      var endIndex, endString, good, header, headerText, i, k, ref, tryIndex, unicodeArray;
      if (data instanceof ArrayBuffer) {
        unicodeArray = new Uint8Array(data);
        endString = "end_header";
        endIndex = -1;
        tryIndex = 0;
        while (endIndex < 0) {
          good = true;
          for (i = k = 0, ref = endString.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            if (String.fromCharCode(unicodeArray[tryIndex + i]) !== endString[i]) {
              good = false;
              break;
            }
          }
          if (good) {
            endIndex = tryIndex + endString.length + 1;
          }
          tryIndex++;
          if (tryIndex > 10000) {
            return;
          }
        }
        headerText = String.fromCharCode.apply(null, new Uint8Array(data, 0, endIndex));
        header = this.parseHeader(headerText);
        if (this.isASCII(header)) {
          return this.parseASCII(this.bin2str(data));
        } else {
          return this.parseBinary(data, header);
        }
      } else {
        return this.parseASCII(data);
      }
    };

    PLYWorker.prototype.parseHeader = function(data) {
      var currentElement, header, headerLength, headerText, i, k, line, lineType, lineValues, lines, make_ply_element_property, patternHeader, ref, result;
      patternHeader = /ply([\s\S]*)end_header\s/;
      headerText = '';
      headerLength = 0;
      result = patternHeader.exec(data);
      make_ply_element_property = function(propertValues, propertyNameMapping) {
        var property;
        property = {
          type: propertValues[0]
        };
        if (property.type === 'list') {
          property.name = propertValues[3];
          property.countType = propertValues[1];
          property.itemType = propertValues[2];
        } else {
          property.name = propertValues[1];
        }
        if (property.name in propertyNameMapping) {
          property.name = propertyNameMapping[property.name];
        }
        return property;
      };
      if (result !== null) {
        headerText = result[1];
        headerLength = result[0].length;
      }
      header = {
        comments: [],
        elements: [],
        headerLength: headerLength
      };
      lines = headerText.split('\n');
      currentElement = void 0;
      lineType = void 0;
      lineValues = void 0;
      for (i = k = 0, ref = lines.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        line = lines[i];
        line = line.trim();
        if (line === '') {
          continue;
        }
        lineValues = line.split(/\s+/);
        lineType = lineValues.shift();
        line = lineValues.join(' ');
        switch (lineType) {
          case 'format':
            header.format = lineValues[0];
            header.version = lineValues[1];
            break;
          case 'comment':
            header.comments.push(line);
            break;
          case 'element':
            if (!(currentElement === void 0)) {
              header.elements.push(currentElement);
            }
            currentElement = Object();
            currentElement.name = lineValues[0];
            currentElement.count = parseInt(lineValues[1]);
            currentElement.properties = [];
            break;
          case 'property':
            currentElement.properties.push(make_ply_element_property(lineValues, this.propertyNameMapping));
            break;
          default:
            console.log('unhandled', lineType, lineValues);
        }
      }
      if (!(currentElement === void 0)) {
        header.elements.push(currentElement);
      }
      return header;
    };

    PLYWorker.prototype.parseASCIINumber = function(n, type) {
      switch (type) {
        case 'char':
        case 'uchar':
        case 'short':
        case 'ushort':
        case 'int':
        case 'uint':
        case 'int8':
        case 'uint8':
        case 'int16':
        case 'uint16':
        case 'int32':
        case 'uint32':
          return parseInt(n);
        case 'float':
        case 'double':
        case 'float32':
        case 'float64':
          return parseFloat(n);
      }
    };

    PLYWorker.prototype.parseASCIIElement = function(properties, line) {
      var element, i, j, k, l, list, n, ref, ref1, ref2, values;
      values = line.split(/\s+/);
      element = Object();
      i = 0;
      for (i = k = ref = i, ref1 = properties.length; ref <= ref1 ? k < ref1 : k > ref1; i = ref <= ref1 ? ++k : --k) {
        if (properties[i].type === 'list') {
          list = [];
          n = this.parseASCIINumber(values.shift(), properties[i].countType);
          for (j = l = 0, ref2 = n; 0 <= ref2 ? l < ref2 : l > ref2; j = 0 <= ref2 ? ++l : --l) {
            list.push(this.parseASCIINumber(values.shift(), properties[i].itemType));
          }
          element[properties[i].name] = list;
        } else {
          element[properties[i].name] = this.parseASCIINumber(values.shift(), properties[i].type);
        }
      }
      return element;
    };

    PLYWorker.prototype.parseASCII = function(data) {
      var body, currentElement, currentElementCount, element, geometry, header, i, k, line, lines, patternBody, ref, result;
      geometry = new THREE.Geometry;
      result = void 0;
      header = this.parseHeader(data);
      patternBody = /end_header\s([\s\S]*)$/;
      body = '';
      if ((result = patternBody.exec(data)) !== null) {
        body = result[1];
      }
      lines = body.split('\n');
      currentElement = 0;
      currentElementCount = 0;
      geometry.useColor = false;
      i = 0;
      for (i = k = 0, ref = lines.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        line = lines[i];
        line = line.trim();
        if (line === '') {
          continue;
        }
        if (currentElementCount >= header.elements[currentElement].count) {
          currentElement++;
          currentElementCount = 0;
        }
        element = this.parseASCIIElement(header.elements[currentElement].properties, line);
        this.handleElement(geometry, header.elements[currentElement].name, element);
        currentElementCount++;
      }
      return this.postProcess(geometry);
    };

    PLYWorker.prototype.postProcess = function(geometry) {
      geometry.computeBoundingSphere();
      return geometry;
    };

    PLYWorker.prototype.binaryRead = function(dataReader, type, little_endian) {
      var value;
      switch (type) {
        case 'int8':
        case 'char':
          value = dataReader.dataView.getInt8(dataReader.location);
          dataReader.location += 1;
          return value;
        case 'uint8':
        case 'uchar':
          value = dataReader.dataView.getUint8(dataReader.location);
          dataReader.location += 1;
          return value;
        case 'int16':
        case 'short':
          value = dataReader.dataView.getInt16(dataReader.location, little_endian);
          dataReader.location += 2;
          return value;
        case 'uint16':
        case 'ushort':
          value = dataReader.dataView.getUint16(dataReader.location, little_endian);
          dataReader.location += 2;
          return value;
        case 'int32':
        case 'int':
          value = dataReader.dataView.getInt32(dataReader.location, little_endian);
          dataReader.location += 4;
          return value;
        case 'uint32':
        case 'uint':
          value = ataReader.dataView.getUint32(dataReader.location, little_endian);
          dataReader.location += 4;
          return value;
        case 'float32':
        case 'float':
          value = dataReader.dataView.getFloat32(dataReader.location, little_endian);
          dataReader.location += 4;
          return value;
        case 'float64':
        case 'double':
          value = dataReader.dataView.getFloat64(dataReader.location, little_endian);
          dataReader.location += 8;
          return value;
      }
    };

    PLYWorker.prototype.parseBinary = function(data, header) {
      var buffers, completedElements, dataReader, element, geometry, i, j, k, l, len, len1, len2, len3, little_endian, m, n, o, p, percentageChangeAt, property, q, ref, ref1, ref2, ref3, ref4, ref5, totalElements, value;
      little_endian = header.format === 'binary_little_endian';
      buffers = {};
      totalElements = 0;
      completedElements = 0;
      ref = header.elements;
      for (k = 0, len = ref.length; k < len; k++) {
        element = ref[k];
        totalElements += element.count;
        switch (element.name) {
          case 'vertex':
            ref1 = element.properties;
            for (l = 0, len1 = ref1.length; l < len1; l++) {
              property = ref1[l];
              switch (property.name) {
                case 'x':
                case 'y':
                case 'z':
                  buffers.positions = new Float32Array(element.count * 3);
                  break;
                case 'red':
                case 'green':
                case 'blue':
                  buffers.colors = new Float32Array(element.count * 3);
              }
            }
            break;
          case 'face':
            buffers.indices = new Uint32Array(element.count * 3);
        }
      }
      dataReader = {
        dataView: new DataView(data, header.headerLength),
        location: 0
      };
      percentageChangeAt = Math.floor(totalElements / 100);
      ref2 = header.elements;
      for (m = 0, len2 = ref2.length; m < len2; m++) {
        element = ref2[m];
        for (i = o = 0, ref3 = element.count; 0 <= ref3 ? o < ref3 : o > ref3; i = 0 <= ref3 ? ++o : --o) {
          ref4 = element.properties;
          for (p = 0, len3 = ref4.length; p < len3; p++) {
            property = ref4[p];
            if (property.type === 'list') {
              n = this.binaryRead(dataReader, property.countType, little_endian);
              for (j = q = 0, ref5 = n; 0 <= ref5 ? q < ref5 : q > ref5; j = 0 <= ref5 ? ++q : --q) {
                value = this.binaryRead(dataReader, property.itemType, little_endian);
                buffers.indices[i * 3 + j] = value;
              }
            } else {
              value = this.binaryRead(dataReader, property.type, little_endian);
              switch (property.name) {
                case 'x':
                  buffers.positions[i * 3] = value;
                  break;
                case 'y':
                  buffers.positions[i * 3 + 1] = value;
                  break;
                case 'z':
                  buffers.positions[i * 3 + 2] = value;
                  break;
                case 'red':
                  buffers.colors[i * 3] = value / 255.0;
                  break;
                case 'green':
                  buffers.colors[i * 3 + 1] = value / 255.0;
                  break;
                case 'blue':
                  buffers.colors[i * 3 + 2] = value / 255.0;
              }
            }
          }
          completedElements++;
          if (completedElements % percentageChangeAt === 0) {
            postMessage({
              type: 'progress',
              loadPercentage: 100.0 * completedElements / totalElements
            });
          }
        }
      }
      geometry = new THREE.BufferGeometry();
      if (buffers.positions) {
        geometry.addAttribute('position', new THREE.BufferAttribute(buffers.positions, 3));
      }
      if (buffers.indices) {
        geometry.setIndex(new THREE.BufferAttribute(buffers.indices, 1));
      }
      geometry.computeVertexNormals();
      buffers.normals = geometry.attributes.normal.array;
      buffers;
      return buffers;
    };

    return PLYWorker;

  })();

}).call(this);

//# sourceMappingURL=plyloader-worker.js.map
