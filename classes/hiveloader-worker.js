// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var HiveWorker;

  importScripts('../libraries/three.min.js');

  self.onmessage = function(message) {
    var loadStart, loader, url;
    url = message.data.url;
    loader = new THREE.XHRLoader(this.manager);
    loader.setResponseType('arraybuffer');
    loadStart = new Date();
    return loader.load(url, (function(_this) {
      return function(data) {
        var loadEnd, loadTime, worker;
        loadEnd = new Date();
        loadTime = loadEnd - loadStart;
        console.log("Loaded in " + loadTime + "ms", url);
        worker = new HiveWorker();
        postMessage({
          type: 'result',
          objects: worker.parse(data, url)
        });
        return close();
      };
    })(this));
  };

  HiveWorker = (function() {
    function HiveWorker() {}

    HiveWorker.prototype.parse = function(data, url) {
      var color, colorData, colors, elements, elementsName, faceCount, filename, filenameStartIndex, flags, frame, frameIndexRegex, hasNormals, headerData, i, indices, isIndexed, j, k, l, m, matches, n, nodes, nodesName, positionData, positions, ref, ref1, scalarName, scalars, time, value, vertexColorFactor, vertexColorOffset, vertexCount, vertexDataSize, vertexNormalOffset, vertexPositionOffset;
      headerData = new Uint32Array(data, 0, 12);
      flags = headerData[0];
      vertexCount = headerData[1];
      faceCount = headerData[2];
      isIndexed = flags & 256;
      hasNormals = flags & 8;
      vertexDataSize = 4;
      if (hasNormals) {
        vertexDataSize += 3;
      }
      vertexPositionOffset = 0;
      vertexColorOffset = hasNormals ? 6 : 3;
      vertexNormalOffset = 3;
      vertexColorFactor = 4;
      positionData = new Float32Array(data, 12, vertexCount * vertexDataSize);
      colorData = new Uint8Array(data, 12, vertexCount * vertexDataSize * vertexColorFactor);
      positions = new Float32Array(vertexCount * 3);
      colors = new Float32Array(vertexCount * 3);
      this._totalElements = vertexCount * 2;
      if (hasNormals) {
        this._totalElements += vertexCount;
      }
      this._percentageChangeAt = Math.floor(this._totalElements / 100);
      this._completedElements = 0;
      for (i = k = 0, ref = vertexCount; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        for (j = l = 0; l < 3; j = ++l) {
          positions[i * 3 + j] = positionData[i * vertexDataSize + vertexPositionOffset + j];
        }
        this.reportProgress();
        for (j = m = 0; m <= 2; j = ++m) {
          color = colorData[(i * vertexDataSize + vertexColorOffset) * vertexColorFactor + j];
          colors[i * 3 + j] = color / 256.0;
        }
        this.reportProgress();
      }

      /*
      if hasNormals
        normalData = new Float32Array data, 12, vertexCount * vertexDataSize
        normals = new Float32Array vertexCount * 3
      
        for i in [0...vertexCount]
          for j in [0..2]
            normals[i * 3 + j] = normalData[i * vertexDataSize + vertexNormalOffset + j]
      
          @reportProgress()
      
        buffers.normals = normals
       */
      if (isIndexed) {
        indices = new Uint32Array(data, 12 + vertexCount * vertexDataSize * 4, faceCount * 3);
      }
      filenameStartIndex = url.lastIndexOf('/') + 1;
      filename = url.substring(filenameStartIndex);
      nodesName = filename + ".nodes";
      nodes = {};
      nodes[nodesName] = {
        nodes: positions
      };
      elementsName = filename + ".elements";
      elements = {};
      if (indices) {
        elements[elementsName] = {
          elements: indices,
          nodesName: nodesName
        };
      }
      frameIndexRegex = /(\d+)(?!.*\d)/;
      matches = filename.match(frameIndexRegex);
      time = matches[0] ? parseFloat(matches[0]) : -1;
      frame = {
        time: time,
        scalars: new Float32Array(vertexCount),
        minValue: null,
        maxValue: null
      };
      color = new THREE.Color;
      for (i = n = 0, ref1 = vertexCount; 0 <= ref1 ? n < ref1 : n > ref1; i = 0 <= ref1 ? ++n : --n) {
        color.setRGB(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
        value = -color.getHSL().h;
        frame.scalars[i] = value;
        if (!((frame.minValue != null) && frame.minValue < value)) {
          frame.minValue = value;
        }
        if (!((frame.maxValue != null) && frame.maxValue > value)) {
          frame.maxValue = value;
        }
      }
      scalarName = filename + ".scalar";
      scalars = {};
      scalars[nodesName] = {};
      scalars[nodesName][scalarName] = {
        scalarName: scalarName,
        nodesName: nodesName,
        frames: [frame]
      };
      return {
        nodes: nodes,
        elements: elements,
        vectors: {},
        scalars: scalars
      };
    };

    HiveWorker.prototype.reportProgress = function() {
      this._completedElements++;
      if (this._completedElements % this._percentageChangeAt === 0) {
        return postMessage({
          type: 'progress',
          loadPercentage: 100.0 * this._completedElements / this._totalElements
        });
      }
    };

    return HiveWorker;

  })();

}).call(this);

//# sourceMappingURL=hiveloader-worker.js.map
