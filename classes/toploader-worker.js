// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var TopParser;

  importScripts('../libraries/three.min.js');

  self.onmessage = function(message) {
    var loadChunk, parser, rangeHeader, rangeHeaderParts, rangeLength, request, requestRangeEnd, requestRangeStart, totalLength, url;
    url = message.data.url;
    parser = new TopParser(url);
    rangeLength = 100 * 1024 * 1024;
    requestRangeStart = 0;
    requestRangeEnd = rangeLength - 1;
    request = new XMLHttpRequest;
    request.open('GET', url, false);
    request.setRequestHeader('Range', "bytes=0-0");
    request.send(null);
    rangeHeader = request.getResponseHeader('Content-Range');
    rangeHeaderParts = rangeHeader.match(/bytes (\d+)-(\d+)\/(\d+)/);
    totalLength = parseInt(rangeHeaderParts[3]);
    loadChunk = (function(_this) {
      return function() {
        requestRangeEnd = Math.min(requestRangeEnd, totalLength - 1);
        request = new XMLHttpRequest;
        request.open('GET', url);
        request.setRequestHeader('Range', "bytes=" + requestRangeStart + "-" + requestRangeEnd);
        request.responseType = 'blob';
        request.onload = function(event) {
          var rangeEnd, rangeStart, reader;
          rangeHeader = request.getResponseHeader('Content-Range');
          rangeHeaderParts = rangeHeader.match(/bytes (\d+)-(\d+)\/(\d+)/);
          rangeStart = parseInt(rangeHeaderParts[1]);
          rangeEnd = parseInt(rangeHeaderParts[2]);
          totalLength = parseInt(rangeHeaderParts[3]);
          if (requestRangeStart !== rangeStart) {
            console.error("Returned range start does not match our request.");
          }
          if (requestRangeEnd !== rangeEnd) {
            console.error("Returned range end does not match our request.");
          }
          reader = new FileReader;
          reader.onload = function(event) {
            parser.parse(reader.result, rangeStart / totalLength, (rangeEnd - rangeStart) / totalLength);
            if (rangeEnd === totalLength - 1) {
              return parser.end();
            }
          };
          reader.readAsText(request.response);
          if (rangeEnd < totalLength - 1) {
            requestRangeStart += rangeLength;
            requestRangeEnd += rangeLength;
            return loadChunk();
          } else {

          }
        };
        return request.send();
      };
    })(this);
    return loadChunk();
  };

  TopParser = (function() {
    TopParser.modes = {
      Nodes: 'Nodes',
      Elements: 'Elements',
      VectorCount: 'VectorCount',
      VectorTime: 'VectorTime',
      Vector: 'Vector',
      ScalarCount: 'ScalarCount',
      ScalarTime: 'ScalarTime',
      Scalar: 'Scalar'
    };

    function TopParser(url1) {
      this.url = url1;
      this.lastLine = null;
      this.currentMode = null;
      this.nodes = {};
      this.currentNodesName = null;
      this.currentNodes = null;
      this.elements = {};
      this.currentElementsName = null;
      this.currentElements = null;
      this.vectors = {};
      this.currentVectorNodesName = null;
      this.currentVectorName = null;
      this.currentVector = null;
      this.scalars = {};
      this.currentScalarNodesName = null;
      this.currentScalarName = null;
      this.currentScalar = null;
      this.currentFrame = null;
      this.currentFrameTime = null;
      this.currentFrameNodesCount = null;
      this.currentFrameNodeIndex = null;
      this.reportedProgressPercentage = 0;
    }

    TopParser.prototype.parse = function(data, progressPercentageStart, progressPercentageLength) {
      var k, lastLineIsComplete, lineIndex, lines, parseLineCount, ref;
      if (data[0] === '\n') {
        this.parseLine(this.lastLine);
        this.lastLine = null;
      }
      lines = data.match(/[^\r\n]+/g);
      lastLineIsComplete = false;
      if (data[data.length - 1] === '\n') {
        lastLineIsComplete = true;
      }
      parseLineCount = lastLineIsComplete ? lines.length : lines.length - 1;
      if (this.lastLine) {
        lines[0] = "" + this.lastLine + lines[0];
      }
      if (parseLineCount > 0) {
        for (lineIndex = k = 0, ref = parseLineCount; 0 <= ref ? k < ref : k > ref; lineIndex = 0 <= ref ? ++k : --k) {
          this.parseLine(lines[lineIndex]);
          this.reportProgress(progressPercentageStart + progressPercentageLength * lineIndex / (parseLineCount - 1));
        }
      }
      return this.lastLine = lastLineIsComplete ? null : lines[lines.length - 1];
    };

    TopParser.prototype.parseLine = function(line) {
      var base, base1, base2, elementIndex, elementType, name, name1, newElement, parts, value, vertex, vertexIndex;
      parts = line.match(/\S+/g);
      switch (parts[0]) {
        case 'Nodes':
          this.currentMode = this.constructor.modes.Nodes;
          this.currentNodesName = parts[1];
          this.currentNodes = {
            nodes: []
          };
          this.nodes[this.currentNodesName] = this.currentNodes;
          return;
        case 'Elements':
          this.currentMode = this.constructor.modes.Elements;
          this.currentElementsName = parts[1];
          this.currentElements = {
            elements: {},
            nodesName: parts[3]
          };
          this.elements[this.currentElementsName] = this.currentElements;
          return;
        case 'Vector':
          this.currentMode = this.constructor.modes.VectorCount;
          this.currentVectorNodesName = parts[5];
          this.currentVectorName = parts[1];
          this.currentVector = {
            vectorName: parts[1],
            nodesName: parts[5],
            frames: []
          };
          if ((base = this.vectors)[name = this.currentVectorNodesName] == null) {
            base[name] = {};
          }
          this.vectors[this.currentVectorNodesName][this.currentVectorName] = this.currentVector;
          return;
        case 'Scalar':
          this.currentMode = this.constructor.modes.ScalarCount;
          this.currentScalarNodesName = parts[5];
          this.currentScalarName = parts[1];
          this.currentScalar = {
            scalarName: parts[1],
            nodesName: parts[5],
            frames: []
          };
          if ((base1 = this.scalars)[name1 = this.currentScalarNodesName] == null) {
            base1[name1] = {};
          }
          this.scalars[this.currentScalarNodesName][this.currentScalarName] = this.currentScalar;
          return;
      }
      switch (this.currentMode) {
        case this.constructor.modes.Nodes:
          vertexIndex = parseInt(parts[0]);
          vertex = {
            x: parseFloat(parts[1]),
            y: parseFloat(parts[2]),
            z: parseFloat(parts[3])
          };
          return this.currentNodes.nodes[vertexIndex] = vertex;
        case this.constructor.modes.Elements:
          elementIndex = parseInt(parts[0]);
          elementType = parseInt(parts[1]);
          if ((base2 = this.currentElements.elements)[elementType] == null) {
            base2[elementType] = [];
          }
          switch (elementType) {
            case 4:
              newElement = [parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4])];
              break;
            case 5:
              newElement = [parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5])];
              break;
            default:
              console.error("UNKNOWN ELEMENT TYPE", elementType, parts, line, this.lastLine);
          }
          return this.currentElements.elements[elementType].push(newElement);
        case this.constructor.modes.VectorCount:
          this.currentFrameNodesCount = parseInt(parts[0]);
          return this.currentMode = this.constructor.modes.VectorTime;
        case this.constructor.modes.VectorTime:
          this.currentFrameTime = parseFloat(parts[0]);
          this.currentMode = this.constructor.modes.Vector;
          this.currentFrame = {
            time: this.currentFrameTime,
            vectors: new Float32Array(this.currentFrameNodesCount * 3)
          };
          this.currentVector.frames.push(this.currentFrame);
          return this.currentFrameNodeIndex = 0;
        case this.constructor.modes.Vector:
          this.currentFrame.vectors[this.currentFrameNodeIndex * 3] = parseFloat(parts[0]);
          this.currentFrame.vectors[this.currentFrameNodeIndex * 3 + 1] = parseFloat(parts[1]);
          this.currentFrame.vectors[this.currentFrameNodeIndex * 3 + 2] = parseFloat(parts[2]);
          this.currentFrameNodeIndex++;
          if (this.currentFrameNodeIndex === this.currentFrameNodesCount) {
            return this.currentMode = this.constructor.modes.VectorTime;
          }
          break;
        case this.constructor.modes.ScalarCount:
          this.currentFrameNodesCount = parseInt(parts[0]);
          return this.currentMode = this.constructor.modes.ScalarTime;
        case this.constructor.modes.ScalarTime:
          this.currentFrameTime = parseFloat(parts[0]);
          this.currentMode = this.constructor.modes.Scalar;
          this.currentFrame = {
            time: this.currentFrameTime,
            scalars: new Float32Array(this.currentFrameNodesCount),
            minValue: null,
            maxValue: null
          };
          this.currentScalar.frames.push(this.currentFrame);
          return this.currentFrameNodeIndex = 0;
        case this.constructor.modes.Scalar:
          value = parseFloat(parts[0]);
          if (!((this.currentFrame.minValue != null) && this.currentFrame.minValue < value)) {
            this.currentFrame.minValue = value;
          }
          if (!((this.currentFrame.maxValue != null) && this.currentFrame.maxValue > value)) {
            this.currentFrame.maxValue = value;
          }
          this.currentFrame.scalars[this.currentFrameNodeIndex] = value;
          this.currentFrameNodeIndex++;
          if (this.currentFrameNodeIndex === this.currentFrameNodesCount) {
            return this.currentMode = this.constructor.modes.ScalarTime;
          }
      }
    };

    TopParser.prototype.end = function() {
      var buffer, elementSize, elementsInstance, elementsList, elementsName, elementsType, i, j, k, l, length, m, nodesInstance, nodesName, nodesPerElement, ref, ref1, ref2, ref3, ref4, ref5;
      ref = this.nodes;
      for (nodesName in ref) {
        nodesInstance = ref[nodesName];
        length = Math.max(0, nodesInstance.nodes.length - 1);
        buffer = new Float32Array(length * 3);
        for (i = k = 0, ref1 = length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
          buffer[i * 3] = nodesInstance.nodes[i + 1].x;
          buffer[i * 3 + 1] = nodesInstance.nodes[i + 1].y;
          buffer[i * 3 + 2] = nodesInstance.nodes[i + 1].z;
        }
        nodesInstance.nodes = buffer;
      }
      nodesPerElement = {
        "4": 3,
        "5": 4
      };
      ref2 = this.elements;
      for (elementsName in ref2) {
        elementsInstance = ref2[elementsName];
        ref3 = elementsInstance.elements;
        for (elementsType in ref3) {
          elementsList = ref3[elementsType];
          elementSize = nodesPerElement[elementsType];
          buffer = new Uint32Array(elementsList.length * elementSize);
          for (i = l = 0, ref4 = elementsList.length; 0 <= ref4 ? l < ref4 : l > ref4; i = 0 <= ref4 ? ++l : --l) {
            for (j = m = 0, ref5 = elementSize; 0 <= ref5 ? m < ref5 : m > ref5; j = 0 <= ref5 ? ++m : --m) {
              buffer[i * elementSize + j] = elementsList[i][j] - 1;
            }
          }
          elementsInstance.elements[elementsType] = buffer;
        }
      }
      return postMessage({
        type: 'result',
        objects: {
          nodes: this.nodes,
          elements: this.elements,
          vectors: this.vectors,
          scalars: this.scalars
        }
      });
    };

    TopParser.prototype.reportProgress = function(percentage) {
      var newPercentage;
      newPercentage = Math.floor(percentage * 100);
      if (newPercentage > this.reportedProgressPercentage) {
        this.reportedProgressPercentage = newPercentage;
        return postMessage({
          type: 'progress',
          loadPercentage: newPercentage
        });
      }
    };

    return TopParser;

  })();

}).call(this);

//# sourceMappingURL=toploader-worker.js.map
